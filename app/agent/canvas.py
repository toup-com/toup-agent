"""
Canvas / A2UI (Agent-to-UI) — Agent-driven visual workspace.

The agent can push HTML, JS, data, and commands to a frontend canvas
that users view in their browser. This enables:
  * Dynamic dashboards and visualizations
  * Interactive forms generated by the agent
  * Code previews and live editors
  * Rich media presentations

Protocol:
  Agent calls canvas tool → content pushed via WebSocket → frontend renders.
  Frontend can send back events (clicks, form submissions) → agent processes.
"""

from __future__ import annotations

import asyncio
import json
import logging
import time
import uuid
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Callable, Dict, List, Optional

logger = logging.getLogger(__name__)


class CanvasContentType(str, Enum):
    """Types of content the agent can push to the canvas."""
    HTML = "html"
    MARKDOWN = "markdown"
    JSON_DATA = "json_data"
    CHART = "chart"
    CODE = "code"
    IMAGE = "image"
    IFRAME = "iframe"
    CUSTOM = "custom"


@dataclass
class CanvasFrame:
    """A single frame/panel in the canvas."""
    frame_id: str
    content_type: CanvasContentType
    content: str
    title: str = ""
    metadata: Dict[str, Any] = field(default_factory=dict)
    created_at: float = field(default_factory=time.time)
    updated_at: float = field(default_factory=time.time)


@dataclass
class CanvasState:
    """Full state of a user's canvas."""
    user_id: str
    visible: bool = False
    frames: Dict[str, CanvasFrame] = field(default_factory=dict)
    layout: str = "stack"  # stack | grid | tabs | split
    created_at: float = field(default_factory=time.time)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "user_id": self.user_id,
            "visible": self.visible,
            "layout": self.layout,
            "frames": {
                fid: {
                    "frame_id": f.frame_id,
                    "content_type": f.content_type.value,
                    "content": f.content,
                    "title": f.title,
                    "metadata": f.metadata,
                    "created_at": f.created_at,
                    "updated_at": f.updated_at,
                }
                for fid, f in self.frames.items()
            },
            "frame_count": len(self.frames),
        }


class CanvasManager:
    """
    Manages canvas states for all users and dispatches updates
    to connected WebSocket clients.
    """

    def __init__(self):
        self._states: Dict[str, CanvasState] = {}
        self._listeners: Dict[str, List[Callable]] = {}  # user_id → [ws_callback]

    def _get_state(self, user_id: str) -> CanvasState:
        if user_id not in self._states:
            self._states[user_id] = CanvasState(user_id=user_id)
        return self._states[user_id]

    # ── Listener management (for WebSocket push) ──

    def add_listener(self, user_id: str, callback: Callable):
        """Register a WebSocket callback for canvas updates."""
        self._listeners.setdefault(user_id, []).append(callback)

    def remove_listener(self, user_id: str, callback: Callable):
        """Remove a WebSocket callback."""
        if user_id in self._listeners:
            self._listeners[user_id] = [
                cb for cb in self._listeners[user_id] if cb != callback
            ]

    async def _notify(self, user_id: str, event_type: str, data: Dict):
        """Push an update to all listeners for a user."""
        msg = {"type": f"canvas_{event_type}", "data": data}
        for cb in self._listeners.get(user_id, []):
            try:
                await cb(msg)
            except Exception as e:
                logger.warning("[CANVAS] Listener error: %s", e)

    # ── Agent actions ──

    async def present(self, user_id: str, content: str,
                      content_type: str = "html", title: str = "",
                      frame_id: Optional[str] = None,
                      metadata: Optional[Dict] = None) -> Dict[str, Any]:
        """
        Present content on the user's canvas.
        Creates or updates a frame.
        """
        state = self._get_state(user_id)
        state.visible = True

        fid = frame_id or f"frame_{uuid.uuid4().hex[:8]}"
        ct = CanvasContentType(content_type) if content_type in CanvasContentType.__members__.values() else CanvasContentType.HTML

        if fid in state.frames:
            frame = state.frames[fid]
            frame.content = content
            frame.content_type = ct
            frame.title = title or frame.title
            frame.metadata = metadata or frame.metadata
            frame.updated_at = time.time()
        else:
            frame = CanvasFrame(
                frame_id=fid,
                content_type=ct,
                content=content,
                title=title,
                metadata=metadata or {},
            )
            state.frames[fid] = frame

        await self._notify(user_id, "present", {
            "frame_id": fid,
            "content_type": ct.value,
            "content": content,
            "title": title,
        })

        logger.info("[CANVAS] Presented frame %s for user %s", fid, user_id[:8])
        return {"frame_id": fid, "visible": True, "frame_count": len(state.frames)}

    async def hide(self, user_id: str) -> Dict[str, str]:
        """Hide the canvas (but preserve state)."""
        state = self._get_state(user_id)
        state.visible = False
        await self._notify(user_id, "hide", {"visible": False})
        return {"status": "hidden"}

    async def show(self, user_id: str) -> Dict[str, str]:
        """Show the canvas."""
        state = self._get_state(user_id)
        state.visible = True
        await self._notify(user_id, "show", state.to_dict())
        return {"status": "visible", "frame_count": len(state.frames)}

    async def clear(self, user_id: str,
                    frame_id: Optional[str] = None) -> Dict[str, str]:
        """Clear canvas frames. If frame_id given, clear only that frame."""
        state = self._get_state(user_id)
        if frame_id:
            removed = state.frames.pop(frame_id, None)
            if not removed:
                return {"error": f"Frame not found: {frame_id}"}
            await self._notify(user_id, "clear_frame", {"frame_id": frame_id})
            return {"cleared": frame_id, "remaining": len(state.frames)}
        else:
            state.frames.clear()
            await self._notify(user_id, "clear_all", {})
            return {"cleared": "all", "remaining": 0}

    async def set_layout(self, user_id: str, layout: str) -> Dict[str, str]:
        """Set canvas layout mode."""
        valid_layouts = ("stack", "grid", "tabs", "split")
        if layout not in valid_layouts:
            return {"error": f"Invalid layout. Use: {valid_layouts}"}
        state = self._get_state(user_id)
        state.layout = layout
        await self._notify(user_id, "layout", {"layout": layout})
        return {"layout": layout}

    async def evaluate_js(self, user_id: str, code: str) -> Dict[str, str]:
        """Request the frontend to evaluate JavaScript."""
        await self._notify(user_id, "eval", {"code": code})
        return {"status": "eval_sent", "code_length": len(code)}

    async def snapshot(self, user_id: str) -> Dict[str, Any]:
        """Get the current canvas state."""
        state = self._get_state(user_id)
        return state.to_dict()

    def get_state(self, user_id: str) -> Optional[CanvasState]:
        """Get canvas state without creating."""
        return self._states.get(user_id)

    @property
    def active_users(self) -> int:
        return len([s for s in self._states.values() if s.visible])


# ── Global singleton ──
_canvas_manager: Optional[CanvasManager] = None


def get_canvas_manager() -> CanvasManager:
    """Get or create the global canvas manager."""
    global _canvas_manager
    if _canvas_manager is None:
        _canvas_manager = CanvasManager()
    return _canvas_manager
