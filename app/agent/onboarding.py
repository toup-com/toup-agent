"""
Onboarding Wizard — Interactive CLI setup for HexBrain.

Walks the user through initial configuration:
1. Database connection
2. API keys (OpenAI, Anthropic)
3. Telegram bot token
4. Admin credentials
5. Optional: Brave Search, ElevenLabs, Cohere

Generates a .env file with validated settings.

Usage:
    python -m app.agent.onboarding
    # or
    hexbrain onboard
"""

import logging
import os
import re
import secrets
import string
from dataclasses import dataclass, field
from typing import Any, Callable, Dict, List, Optional, Tuple

logger = logging.getLogger(__name__)


@dataclass
class WizardStep:
    """A single step in the onboarding wizard."""
    key: str
    prompt: str
    env_var: str
    required: bool = True
    default: str = ""
    validator: Optional[Callable[[str], Tuple[bool, str]]] = None
    secret: bool = False
    category: str = "general"
    help_text: str = ""

    def validate(self, value: str) -> Tuple[bool, str]:
        """Validate the input value."""
        if self.required and not value and not self.default:
            return False, f"{self.key} is required"
        if self.validator:
            return self.validator(value)
        return True, ""


@dataclass
class WizardResult:
    """Result of running the onboarding wizard."""
    env_vars: Dict[str, str] = field(default_factory=dict)
    skipped: List[str] = field(default_factory=list)
    errors: List[str] = field(default_factory=list)
    completed: bool = False

    def to_env_content(self) -> str:
        """Generate .env file content."""
        lines = ["# HexBrain Configuration", f"# Generated by onboarding wizard", ""]
        
        categories: Dict[str, List[Tuple[str, str]]] = {}
        for key, value in self.env_vars.items():
            cat = "general"
            if "DATABASE" in key or "DB" in key:
                cat = "database"
            elif "API_KEY" in key or "TOKEN" in key or "SECRET" in key:
                cat = "api_keys"
            elif "TELEGRAM" in key:
                cat = "telegram"
            elif "JWT" in key or "ADMIN" in key:
                cat = "auth"
            else:
                cat = "general"
            if cat not in categories:
                categories[cat] = []
            categories[cat].append((key, value))

        cat_labels = {
            "database": "Database",
            "api_keys": "API Keys",
            "telegram": "Telegram",
            "auth": "Authentication",
            "general": "General",
        }

        for cat in ["database", "auth", "api_keys", "telegram", "general"]:
            if cat in categories:
                lines.append(f"# --- {cat_labels.get(cat, cat)} ---")
                for key, value in categories[cat]:
                    lines.append(f"{key}={value}")
                lines.append("")

        return "\n".join(lines)


# ── Validators ────────────────────────────────────────

def validate_url(value: str) -> Tuple[bool, str]:
    if not value:
        return True, ""
    if not re.match(r'^(postgres|postgresql|sqlite)', value):
        return False, "Must be a PostgreSQL or SQLite connection string"
    return True, ""


def validate_api_key(value: str) -> Tuple[bool, str]:
    if not value:
        return True, ""
    if len(value) < 10:
        return False, "API key seems too short"
    return True, ""


def validate_bot_token(value: str) -> Tuple[bool, str]:
    if not value:
        return True, ""
    if ":" not in value:
        return False, "Telegram bot token should contain a colon"
    return True, ""


def validate_port(value: str) -> Tuple[bool, str]:
    if not value:
        return True, ""
    try:
        p = int(value)
        if 1 <= p <= 65535:
            return True, ""
        return False, "Port must be 1-65535"
    except ValueError:
        return False, "Port must be a number"


# ── Steps ─────────────────────────────────────────────

def get_wizard_steps() -> List[WizardStep]:
    """Return the ordered list of wizard steps."""
    return [
        WizardStep(
            key="database_url",
            prompt="Database URL",
            env_var="DATABASE_URL",
            required=True,
            default="postgresql+asyncpg://hexbrain:hexbrain_secret@localhost:5432/hexbrain",
            validator=validate_url,
            category="database",
            help_text="PostgreSQL connection string with asyncpg driver",
        ),
        WizardStep(
            key="jwt_secret",
            prompt="JWT Secret (auto-generated if empty)",
            env_var="JWT_SECRET",
            required=True,
            default="",  # Will be auto-generated
            secret=True,
            category="auth",
            help_text="Secret key for JWT token signing",
        ),
        WizardStep(
            key="admin_password",
            prompt="Admin password",
            env_var="ADMIN_DEFAULT_PASSWORD",
            required=True,
            default="",
            secret=True,
            category="auth",
            help_text="Password for the admin user",
        ),
        WizardStep(
            key="openai_api_key",
            prompt="OpenAI API Key",
            env_var="OPENAI_API_KEY",
            required=True,
            validator=validate_api_key,
            secret=True,
            category="api_keys",
            help_text="OpenAI API key (starts with sk-)",
        ),
        WizardStep(
            key="anthropic_api_key",
            prompt="Anthropic API Key (optional)",
            env_var="ANTHROPIC_API_KEY",
            required=False,
            validator=validate_api_key,
            secret=True,
            category="api_keys",
            help_text="Anthropic API key (for Claude models)",
        ),
        WizardStep(
            key="telegram_bot_token",
            prompt="Telegram Bot Token",
            env_var="TELEGRAM_BOT_TOKEN",
            required=False,
            validator=validate_bot_token,
            secret=True,
            category="telegram",
            help_text="Bot token from @BotFather",
        ),
        WizardStep(
            key="brave_api_key",
            prompt="Brave Search API Key (optional)",
            env_var="BRAVE_API_KEY",
            required=False,
            validator=validate_api_key,
            secret=True,
            category="api_keys",
            help_text="For web search tool",
        ),
        WizardStep(
            key="elevenlabs_api_key",
            prompt="ElevenLabs API Key (optional)",
            env_var="ELEVENLABS_API_KEY",
            required=False,
            secret=True,
            category="api_keys",
            help_text="For voice synthesis",
        ),
        WizardStep(
            key="app_port",
            prompt="Application port",
            env_var="PORT",
            required=False,
            default="8000",
            validator=validate_port,
            category="general",
            help_text="Port for the FastAPI server",
        ),
    ]


def generate_jwt_secret(length: int = 64) -> str:
    """Generate a secure random JWT secret."""
    alphabet = string.ascii_letters + string.digits + "-_"
    return ''.join(secrets.choice(alphabet) for _ in range(length))


def run_wizard_noninteractive(
    answers: Dict[str, str],
) -> WizardResult:
    """
    Run the wizard with pre-supplied answers (for testing/automation).

    Args:
        answers: Dict of step key → value

    Returns:
        WizardResult with env_vars populated
    """
    result = WizardResult()
    steps = get_wizard_steps()

    for step in steps:
        value = answers.get(step.key, "")

        if not value and step.default:
            value = step.default

        # Auto-generate JWT secret
        if step.key == "jwt_secret" and not value:
            value = generate_jwt_secret()

        if not value and not step.required:
            result.skipped.append(step.key)
            continue

        ok, err = step.validate(value)
        if not ok:
            result.errors.append(f"{step.key}: {err}")
            continue

        result.env_vars[step.env_var] = value

    result.completed = len(result.errors) == 0
    return result


def check_existing_config(env_path: str = ".env") -> Dict[str, bool]:
    """Check which config values already exist in .env file."""
    steps = get_wizard_steps()
    existing = {}

    if not os.path.exists(env_path):
        return {s.env_var: False for s in steps}

    with open(env_path) as f:
        content = f.read()

    for step in steps:
        existing[step.env_var] = f"{step.env_var}=" in content

    return existing
